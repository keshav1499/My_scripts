<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Fire Simulation</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000; /* Deep black background for contrast */
        }
        canvas {
            display: block;
        }
        #instruction {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.3);
            font-family: sans-serif;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>

    <div id="instruction">Move cursor quickly to create wind</div>
    <canvas id="fireCanvas"></canvas>

<script>
    const canvas = document.getElementById('fireCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize for no transparency on canvas background

    let width, height;
    
    // Resize handling
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Mouse state for wind calculation
    const mouse = { x: -1000, y: -1000, vx: 0, vy: 0 };
    let lastMouse = { x: 0, y: 0 };

    window.addEventListener('mousemove', e => {
        // Calculate velocity based on movement distance
        mouse.vx = e.clientX - lastMouse.x;
        mouse.vy = e.clientY - lastMouse.y;
        
        mouse.x = e.clientX;
        mouse.y = e.clientY;
        
        lastMouse.x = e.clientX;
        lastMouse.y = e.clientY;
    });

    // Particle settings
    const particles = [];
    const maxParticles = 2000; // Adjust for performance vs density
    
    class Particle {
        constructor() {
            this.reset(true);
        }

        reset(initial = false) {
            // Start at the bottom center
            const spread = 160; // Width of the fire base
            this.x = (width / 2) + (Math.random() * spread - spread / 2);
            this.y = height + (Math.random() * 50); // Start slightly below screen
            
            // Upward velocity (heat rises) + slight random horizontal drift
            this.vx = (Math.random() * 2 - 1); 
            this.vy = -(Math.random() * 3 + 2); // Speed of rise
            
            this.life = 100; // 100% life
            this.decay = Math.random() * 0.5 + 0.5; // How fast it dies
            
            // Size of the flame particle
            this.size = Math.random() * 2 + 15;
            
            // Randomize color slightly (Red/Orange/Yellow)
            // Hue: 0-60 (Red to Yellow), Saturation: 100%, Lightness: 50%
            this.hue = Math.random() * 40 + 10; 

            // If it's the initial load, scatter them vertically so the fire doesn't "pop" in
            if(initial) {
                this.y -= Math.random() * 300;
                this.life = Math.random() * 100;
            }
        }

        update() {
            // 1. Apply Natural Physics
            this.x += this.vx;
            this.y += this.vy;
            
            // Natural turbulence (flame flicker)
            this.vx += (Math.random() * 0.4 - 0.2); 
            
            // 2. Apply Wind (Mouse Interaction)
            // Calculate distance between particle and mouse
            const dx = this.x - mouse.x;
            const dy = this.y - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Interaction radius: 150px
            if (dist < 150) {
                // Apply force based on mouse velocity
                // We divide by distance so closer particles are affected more
                const force = (150 - dist) / 150;
                
                this.vx += (mouse.vx * force) * 0.1; // 0.1 is the 'grip' of the wind
                this.vy += (mouse.vy * force) * 0.1;
            }

            // 3. Aging
            this.life -= this.decay;
            this.size -= 0.15; // Shrink as it goes up

            // 4. Reset if dead or too small
            if (this.life <= 0 || this.size <= 0) {
                this.reset();
            }
        }

        draw() {
            ctx.beginPath();
            
            // Calculate opacity based on life
            const alpha = this.life / 100;
            
            // Dynamic coloring
            // As life drops, hue shifts slightly towards smoke (grey) or deep red
            // Lighter center (high life) -> Darker edges (low life)
            const lightness = (this.life / 100) * 50 + 10; // 60% down to 10%
            
            ctx.fillStyle = `hsla(${this.hue}, 100%, ${lightness}%, ${alpha})`;
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Initialize particles
    for (let i = 0; i < maxParticles; i++) {
        particles.push(new Particle());
    }

    // Animation Loop
    function animate() {
        // Clear screen with a slight trail effect (optional, but looks good)
        // Using clearRect helps keep the background pure black
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, width, height);

        // "Lighter" composite operation makes overlapping particles glow white-hot
        ctx.globalCompositeOperation = 'lighter';

        particles.forEach(p => {
            p.update();
            p.draw();
        });

        // Friction on mouse velocity (wind dies down if mouse stops)
        mouse.vx *= 0.1;
        mouse.vy *= 0.1;

        requestAnimationFrame(animate);
    }

    animate();

</script>
</body>
</html>
